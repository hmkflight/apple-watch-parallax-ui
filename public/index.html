<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple Watch Parallax UI</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; }
    #graph { position: fixed; inset: 0; width: 100vw; height: 100vh; }
    #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #0f0; padding: 8px; font-family: monospace; font-size: 11px; z-index: 1000; pointer-events: none; }
  </style>

  <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
  <script src="//unpkg.com/d3-force@3"></script>
  <!--<script src="../../dist/force-graph.js"></script>-->
</head>

<body>
  <div id="graph"></div>
  <div id="debug"></div>

  <script>
    // Generate hex coordinates in concentric rings (Apple Watch style)
    function generateHexRings(N, spacing) {
      const positions = [];
      const sqrt3 = Math.sqrt(3);

      // Axial hex directions (6 sides of hexagon)
      const dirs = [
        [+1,  0], [+1, -1], [ 0, -1],
        [-1,  0], [-1, +1], [ 0, +1]
      ];

      // Center hex
      positions.push({ q: 0, r: 0 });

      // Generate rings outward from center
      let radius = 1;
      while (positions.length < N) {
        // Start at top-left of ring
        let q = -radius;
        let r = 0;

        // Walk around the ring
        for (let side = 0; side < 6; side++) {
          for (let step = 0; step < radius; step++) {
            if (positions.length >= N) break;
            positions.push({ q, r });
            // Move in current direction
            q += dirs[side][0];
            r += dirs[side][1];
          }
          if (positions.length >= N) break;
        }
        radius++;
      }

      // Convert axial (q,r) to pixel (x,y) - pointy-top hex
      return positions.map(({ q, r }) => ({
        x: spacing * sqrt3 * (q + r / 2),
        y: spacing * 1.5 * r
      }));
    }

    // Configuration
    const N = 300;
    const nodeRadius = 18; // Larger circles
    const hexSpacing = 46; // spacing between hex centers (radius*2 + gap)

    const positions = generateHexRings(N, hexSpacing);

    // Create nodes with deterministic honeycomb positions
    const gData = {
      nodes: [...Array(N).keys()].map(i => {
        const pos = positions[i];
        // Ensure finite anchor positions
        const anchorX = Number.isFinite(pos.x) ? pos.x : 0;
        const anchorY = Number.isFinite(pos.y) ? pos.y : 0;
        return {
          id: i,
          x: anchorX,
          y: anchorY,
          anchorX: anchorX, // Home position for anchor force
          anchorY: anchorY,
          radius: nodeRadius
        };
      }),
      links: [] // No links - pure icon field like Apple Watch
    };

    // Custom anchor force to keep honeycomb shape (with clamped acceleration)
    function anchorForce(strength = 0.008) {
      let nodes;
      const MAX_ACCEL = 0.5; // Clamp max acceleration per tick

      function force(alpha) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];

          // Defensive guards against NaN/undefined
          if (!Number.isFinite(node.anchorX)) node.anchorX = 0;
          if (!Number.isFinite(node.anchorY)) node.anchorY = 0;
          if (!Number.isFinite(node.x)) node.x = node.anchorX;
          if (!Number.isFinite(node.y)) node.y = node.anchorY;
          if (!Number.isFinite(node.vx)) node.vx = 0;
          if (!Number.isFinite(node.vy)) node.vy = 0;

          // Calculate clamped acceleration toward anchor
          const ax = (node.anchorX - node.x) * strength;
          const ay = (node.anchorY - node.y) * strength;

          // Clamp to prevent explosion
          node.vx += Math.max(-MAX_ACCEL, Math.min(MAX_ACCEL, ax));
          node.vy += Math.max(-MAX_ACCEL, Math.min(MAX_ACCEL, ay));
        }
      }

      force.initialize = function(_) { nodes = _; };

      return force;
    }

    // Bulletproof sizing using container measurements
    const el = document.getElementById('graph');

    function updateGraphSize() {
      const rect = el.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      Graph.width(w).height(h);
    }

    const Graph = new ForceGraph()
      (el)
        .graphData(gData)
        .nodeVal(node => node.radius * 2) // Size based on radius
        .nodeRelSize(1.5) // Additional size multiplier
        .d3VelocityDecay(0.6) // Higher friction for stability
        .d3AlphaDecay(0.08) // Moderate cooling rate
        .d3Force('charge', null) // Remove charge repulsion
        .d3Force('center', null) // Remove centering force (already centered)
        .d3Force('collide', d3.forceCollide(node => node.radius + 4).iterations(2)) // Prevent overlap
        .d3Force('anchor', anchorForce(0.008)) // Keep honeycomb shape
        .onEngineStop(() => {
          // Force refresh when simulation stops
          Graph.refresh();
        });

    // Apply initial size
    updateGraphSize();

    // ResizeObserver for container size changes
    const resizeObserver = new ResizeObserver(() => {
      updateGraphSize();
    });
    resizeObserver.observe(el);

    // Debug overlay (updates every second)
    const debugEl = document.getElementById('debug');
    setInterval(() => {
      const rect = el.getBoundingClientRect();
      const nodes = Graph.graphData().nodes;
      const anyFinite = nodes.some(n => Number.isFinite(n.x) && Number.isFinite(n.y));

      debugEl.innerHTML = `
        Container: ${Math.floor(rect.width)}Ã—${Math.floor(rect.height)}px<br>
        Zoom: ${Graph.zoom().toFixed(2)}<br>
        Nodes: ${nodes.length}<br>
        Finite positions: ${anyFinite ? 'YES' : 'NO'}
      `;
    }, 1000);

    // Watchdog: force refresh if nodes exist but seem invisible
    setInterval(() => {
      const nodes = Graph.graphData().nodes;
      if (nodes.length > 0) {
        Graph.refresh();
      }
    }, 5000);

    // Calm the simulation on load
    setTimeout(() => {
      Graph.d3AlphaDecay(0.05); // Slow down settling
    }, 500);
  </script>
</body>
</html>
