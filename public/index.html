<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple Watch Parallax UI</title>
  <style> body { margin: 0; } </style>

  <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
  <script src="//unpkg.com/d3-force@3"></script>
  <!--<script src="../../dist/force-graph.js"></script>-->
</head>

<body>
  <div id="graph"></div>

  <script>
    // Generate hex coordinates in concentric rings (Apple Watch style)
    function generateHexRings(N, spacing) {
      const positions = [];
      const sqrt3 = Math.sqrt(3);

      // Axial hex directions (6 sides of hexagon)
      const dirs = [
        [+1,  0], [+1, -1], [ 0, -1],
        [-1,  0], [-1, +1], [ 0, +1]
      ];

      // Center hex
      positions.push({ q: 0, r: 0 });

      // Generate rings outward from center
      let radius = 1;
      while (positions.length < N) {
        // Start at top-left of ring
        let q = -radius;
        let r = 0;

        // Walk around the ring
        for (let side = 0; side < 6; side++) {
          for (let step = 0; step < radius; step++) {
            if (positions.length >= N) break;
            positions.push({ q, r });
            // Move in current direction
            q += dirs[side][0];
            r += dirs[side][1];
          }
          if (positions.length >= N) break;
        }
        radius++;
      }

      // Convert axial (q,r) to pixel (x,y) - pointy-top hex
      return positions.map(({ q, r }) => ({
        x: spacing * sqrt3 * (q + r / 2),
        y: spacing * 1.5 * r
      }));
    }

    // Configuration
    const N = 300;
    const nodeRadius = 18; // Larger circles
    const hexSpacing = 46; // spacing between hex centers (radius*2 + gap)

    const positions = generateHexRings(N, hexSpacing);

    // Create nodes with deterministic honeycomb positions
    const gData = {
      nodes: [...Array(N).keys()].map(i => ({
        id: i,
        x: positions[i].x,
        y: positions[i].y,
        anchorX: positions[i].x, // Home position for anchor force
        anchorY: positions[i].y,
        radius: nodeRadius
      })),
      links: [] // No links - pure icon field like Apple Watch
    };

    // Custom anchor force to keep honeycomb shape
    function anchorForce(strength = 0.008) {
      let nodes;

      function force(alpha) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node.anchorX !== undefined && node.anchorY !== undefined) {
            node.vx += (node.anchorX - node.x) * strength;
            node.vy += (node.anchorY - node.y) * strength;
          }
        }
      }

      force.initialize = function(_) { nodes = _; };

      return force;
    }

    const Graph = new ForceGraph()
      (document.getElementById('graph'))
        .graphData(gData)
        .nodeVal(node => node.radius * 2) // Size based on radius
        .nodeRelSize(1.5) // Additional size multiplier
        .d3VelocityDecay(0.6) // Higher friction for stability
        .d3AlphaDecay(0.08) // Moderate cooling rate
        .d3Force('charge', null) // Remove charge repulsion
        .d3Force('center', null) // Remove centering force (already centered)
        .d3Force('collide', d3.forceCollide(node => node.radius + 4).iterations(2)) // Prevent overlap
        .d3Force('anchor', anchorForce(0.008)); // Keep honeycomb shape

    // Calm the simulation on load
    setTimeout(() => {
      Graph.d3AlphaDecay(0.05); // Slow down settling
    }, 500);
  </script>
</body>
</html>
