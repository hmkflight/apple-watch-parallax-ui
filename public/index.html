<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Apple Watch Parallax</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: grab;
        touch-action: none;
      }
      canvas.dragging {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Configuration
      const NODE_RADIUS = 70;
      const RING_SPACING = 160;
      const LINE_COLOR = 'rgba(80, 80, 80, 0.3)';
      const NODE_COLOR = '#1a1a1a';
      const NODE_STROKE = '#444';
      const TEXT_COLOR = '#fff';

      // Icon data with external logo URLs
      const ICONS = [
        { name: "MasterClass", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/3/34/MasterClass_Logo.svg", href: "/masterclass-kim.html", bgColor: "#000000", type: "link" },
        { name: "Coursera", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/e/e5/Coursera_logo.svg", href: "https://www.coursera.org", bgColor: "#0056D2", type: "link" },
        { name: "Khan Academy", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/0/0c/Khan_Academy_logo_2018.svg", href: "https://www.khanacademy.org", bgColor: "#14BF96", type: "link" },
        { name: "Udemy", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/e/e3/Udemy_logo.svg", href: "https://www.udemy.com", bgColor: "#A435F0", type: "link" },
        { name: "edX", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/c/cd/EdX_newer_logo.svg", href: "https://www.edx.org", bgColor: "#02262B", type: "link" },
        { name: "Skillshare", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/0/0f/Skillshare_logo_2020.svg", href: "https://www.skillshare.com", bgColor: "#00FF84", type: "link" },
        { name: "LinkedIn Learning", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/0/01/LinkedIn_Logo.svg", href: "https://www.linkedin.com/learning/", bgColor: "#0A66C2", type: "link" },
        { name: "Brilliant", logoUrl: "https://brilliant.org/site_media/version-1705077046/images/logos/brilliant-logo-dark.svg", href: "https://brilliant.org", bgColor: "#111111", type: "link" },
        { name: "Duolingo", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/d/d0/Duolingo_logo.svg", href: "https://www.duolingo.com", bgColor: "#58CC02", type: "link" },
        { name: "Codecademy", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/7/7d/Codecademy_logo_2020.svg", href: "https://www.codecademy.com", bgColor: "#1F4056", type: "link" },
        { name: "FutureLearn", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/5/59/FutureLearn_logo.svg", href: "https://www.futurelearn.com", bgColor: "#DE3F7C", type: "link" },
        { name: "Pluralsight", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/3/37/Pluralsight_Logo.svg", href: "https://www.pluralsight.com", bgColor: "#F15B2A", type: "link" },
        { name: "DataCamp", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/5/53/DataCamp_logo_%282019%29.svg", href: "https://www.datacamp.com", bgColor: "#03EF62", type: "link" },
        { name: "Udacity", logoUrl: "https://upload.wikimedia.org/wikipedia/commons/e/e8/Udacity_logo.svg", href: "https://www.udacity.com", bgColor: "#02B3E4", type: "link" },
        { name: "Video", logoUrl: "", href: "PASTE_DRIVE_SHARE_LINK_HERE", bgColor: "#FF0000", type: "video" }
      ];

      // Image cache
      const imageCache = new Map();
      const imageLoadStatus = new Map();

      let nodes = [];
      let links = [];

      // World bounds (for infinite wrap)
      let WORLD_WIDTH = 2000;
      let WORLD_HEIGHT = 2000;

      // Camera state
      let camX = 0;
      let camY = 0;
      let targetCamX = 0;
      let targetCamY = 0;
      const CAM_EASING = 0.15;

      // Zoom state
      let zoom = 1;
      let targetZoom = 1;
      const MIN_ZOOM = 0.6;
      const MAX_ZOOM = 2.5;
      const ZOOM_EASING = 0.2;

      // Interaction state
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartCamX = 0;
      let dragStartCamY = 0;
      let hasDragged = false;

      // Pinch state
      const activePointers = new Map();
      let lastPinchDistance = 0;
      let lastPinchMidX = 0;
      let lastPinchMidY = 0;

      // Lens focus state (screen space)
      let focusX = 0;
      let focusY = 0;
      let targetFocusX = 0;
      let targetFocusY = 0;
      const FOCUS_EASING = 0.2;
      const LENS_RADIUS = 250;
      const LENS_MAX_SCALE = 1.5;

      // Preload images
      function preloadImages() {
        ICONS.forEach(icon => {
          if (!icon.logoUrl) return;

          const img = new Image();
          img.crossOrigin = "anonymous";

          img.onload = () => {
            imageCache.set(icon.logoUrl, img);
            imageLoadStatus.set(icon.logoUrl, 'loaded');
          };

          img.onerror = () => {
            imageLoadStatus.set(icon.logoUrl, 'error');
          };

          imageLoadStatus.set(icon.logoUrl, 'loading');
          img.src = icon.logoUrl;
        });
      }

      // Setup canvas with DPI scaling
      function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        ctx.scale(dpr, dpr);

        return { width: rect.width, height: rect.height };
      }

      // Wrap a value to stay within [-limit/2, +limit/2)
      function wrap(value, limit) {
        const halfLimit = limit / 2;
        return ((value + halfLimit) % limit + limit) % limit - halfLimit;
      }

      // Wrap camera positions for infinite torus world
      function wrapCamera() {
        targetCamX = wrap(targetCamX, WORLD_WIDTH);
        targetCamY = wrap(targetCamY, WORLD_HEIGHT);
        camX = wrap(camX, WORLD_WIDTH);
        camY = wrap(camY, WORLD_HEIGHT);
      }

      // Anchored zoom: adjust camera so world point under screen point stays fixed
      function applyAnchoredZoom(newZoom, screenX, screenY) {
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;

        // World point before zoom (use continuous camera values)
        const worldXBefore = (screenX - centerX - targetCamX) / zoom;
        const worldYBefore = (screenY - centerY - targetCamY) / zoom;

        // Clamp zoom
        targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

        // World point after zoom (should stay at same screen position)
        // screenX = centerX + targetCamX + worldX * targetZoom
        // Solve for new targetCamX/Y
        targetCamX = screenX - centerX - worldXBefore * targetZoom;
        targetCamY = screenY - centerY - worldYBefore * targetZoom;

        // Camera remains continuous (no wrapping)
      }

      // Generate concentric circular layout
      function generateCircularGrid(viewportWidth, viewportHeight) {
        // Calculate how many rings needed to fill viewport (reduced for better performance)
        // Use larger dimension instead of diagonal to avoid excessive corner nodes
        const maxDimension = Math.max(viewportWidth, viewportHeight) / 2;
        const RING_COUNT = Math.ceil(maxDimension / RING_SPACING) + 1;

        nodes = [];
        let nodeId = 0;

        // Center node
        const centerIcon = ICONS[nodeId % ICONS.length];
        nodes.push({
          id: nodeId++,
          x: 0,
          y: 0,
          ring: 0,
          index: 0,
          icon: centerIcon
        });

        // Generate concentric rings
        for (let ring = 1; ring <= RING_COUNT; ring++) {
          const radius = ring * RING_SPACING;
          const circumference = 2 * Math.PI * radius;

          // Calculate how many nodes fit around this ring with proper spacing
          const nodesInRing = Math.max(6, Math.floor(circumference / (NODE_RADIUS * 2.5)));

          for (let i = 0; i < nodesInRing; i++) {
            const angle = (i / nodesInRing) * 2 * Math.PI;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            const iconData = ICONS[nodeId % ICONS.length];
            nodes.push({
              id: nodeId++,
              x,
              y,
              ring,
              index: i,
              nodesInRing,
              icon: iconData
            });
          }
        }

        // Generate neighbor links
        links = [];

        nodes.forEach(node => {
          if (node.ring === 0) return; // Skip center node for now

          // Connect to adjacent nodes in same ring
          const ringStart = nodes.findIndex(n => n.ring === node.ring);
          const ringSize = node.nodesInRing;

          // Next node in same ring
          const nextIndex = (node.index + 1) % ringSize;
          const nextId = ringStart + nextIndex;
          if (node.id < nextId) {
            links.push({ source: node.id, target: nextId });
          }

          // Connect to nodes in inner ring
          if (node.ring > 1) {
            const innerRingStart = nodes.findIndex(n => n.ring === node.ring - 1);
            const innerRing = nodes.filter(n => n.ring === node.ring - 1);

            // Find closest node(s) in inner ring by angle
            const nodeAngle = Math.atan2(node.y, node.x);
            innerRing.forEach(innerNode => {
              const innerAngle = Math.atan2(innerNode.y, innerNode.x);
              const angleDiff = Math.abs(nodeAngle - innerAngle);

              // Connect if angles are close (within reasonable arc)
              if (angleDiff < Math.PI / Math.max(6, innerNode.nodesInRing * 0.8)) {
                if (node.id > innerNode.id) {
                  links.push({ source: innerNode.id, target: node.id });
                }
              }
            });
          } else if (node.ring === 1) {
            // First ring connects to center
            links.push({ source: 0, target: node.id });
          }
        });

        // Calculate world bounds from grid
        if (nodes.length > 0) {
          const padding = 200;
          const minX = Math.min(...nodes.map(n => n.x));
          const maxX = Math.max(...nodes.map(n => n.x));
          const minY = Math.min(...nodes.map(n => n.y));
          const maxY = Math.max(...nodes.map(n => n.y));

          WORLD_WIDTH = (maxX - minX) + padding * 2;
          WORLD_HEIGHT = (maxY - minY) + padding * 2;
        }
      }

      // Render the circular grid with tiled rendering for seamless infinite world
      function render() {
        const { width, height } = setupCanvas();

        ctx.clearRect(0, 0, width, height);

        // Wrap camera for rendering only (portal-style continuous motion)
        const camXWrapped = wrap(camX, WORLD_WIDTH);
        const camYWrapped = wrap(camY, WORLD_HEIGHT);

        // Define 3x3 tile offsets for seamless torus wrapping
        const tileOffsets = [
          { x: -WORLD_WIDTH, y: -WORLD_HEIGHT },
          { x: -WORLD_WIDTH, y: 0 },
          { x: -WORLD_WIDTH, y: WORLD_HEIGHT },
          { x: 0, y: -WORLD_HEIGHT },
          { x: 0, y: 0 },
          { x: 0, y: WORLD_HEIGHT },
          { x: WORLD_WIDTH, y: -WORLD_HEIGHT },
          { x: WORLD_WIDTH, y: 0 },
          { x: WORLD_WIDTH, y: WORLD_HEIGHT }
        ];

        // Render each tile
        tileOffsets.forEach(offset => {
          ctx.save();

          // Apply camera transform: translate to center, apply wrapped camera offset, then scale
          ctx.translate(width / 2, height / 2);
          ctx.translate(camXWrapped, camYWrapped);
          ctx.scale(zoom, zoom);

          // Apply tile offset
          ctx.translate(offset.x, offset.y);

          // Draw links first (behind nodes)
          ctx.strokeStyle = LINE_COLOR;
          ctx.lineWidth = 1.5;

          links.forEach(link => {
            const source = nodes[link.source];
            const target = nodes[link.target];

            ctx.beginPath();
            ctx.moveTo(source.x, source.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
          });

          // Draw nodes with lens magnification
          nodes.forEach(node => {
            // Calculate screen position of this node (using wrapped camera for visuals)
            const screenX = (node.x + offset.x) * zoom + camXWrapped + width / 2;
            const screenY = (node.y + offset.y) * zoom + camYWrapped + height / 2;

            // Calculate distance to focus point
            const dx = screenX - focusX;
            const dy = screenY - focusY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Skip expensive lens calculations if node is far from focus
            let lensScale = 1;
            if (distance <= LENS_RADIUS) {
              // Apply smooth falloff for lens magnification
              const strength = Math.max(0, 1 - distance / LENS_RADIUS);
              lensScale = 1 + (LENS_MAX_SCALE - 1) * strength * strength;
            }

            // Apply magnification transform
            const scaledRadius = NODE_RADIUS * lensScale;

            // Circle background with icon color
            ctx.fillStyle = node.icon.bgColor || NODE_COLOR;
            ctx.strokeStyle = NODE_STROKE;
            ctx.lineWidth = 2.5;

            ctx.beginPath();
            ctx.arc(node.x, node.y, scaledRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Subtle outer glow (reduced for performance)
            ctx.shadowColor = 'rgba(255, 255, 255, 0.08)';
            ctx.shadowBlur = 4 * lensScale;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Subtle inner vignette
            const vignetteGradient = ctx.createRadialGradient(
              node.x, node.y, scaledRadius * 0.6,
              node.x, node.y, scaledRadius
            );
            vignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
            ctx.fillStyle = vignetteGradient;
            ctx.fill();

            // Draw logo or fallback
            const logoUrl = node.icon.logoUrl;
            const logoStatus = imageLoadStatus.get(logoUrl);
            const logoImage = imageCache.get(logoUrl);

            if (logoStatus === 'loaded' && logoImage) {
              // Clip to circle
              ctx.save();
              ctx.beginPath();
              ctx.arc(node.x, node.y, scaledRadius * 0.75, 0, Math.PI * 2);
              ctx.clip();

              // Calculate contain-style fit with padding
              const padding = scaledRadius * 0.15;
              const availableSize = (scaledRadius * 0.75) * 2 - padding * 2;
              const imgAspect = logoImage.width / logoImage.height;
              let drawWidth, drawHeight;

              if (imgAspect > 1) {
                drawWidth = availableSize;
                drawHeight = availableSize / imgAspect;
              } else {
                drawHeight = availableSize;
                drawWidth = availableSize * imgAspect;
              }

              const drawX = node.x - drawWidth / 2;
              const drawY = node.y - drawHeight / 2;

              ctx.drawImage(logoImage, drawX, drawY, drawWidth, drawHeight);
              ctx.restore();
            } else {
              // Fallback: draw first letter
              ctx.fillStyle = TEXT_COLOR;
              const scaledFontSize = Math.round(24 * lensScale);
              ctx.font = `bold ${scaledFontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(node.icon.name[0], node.x, node.y);
            }
          });

          ctx.restore();
        });
      }

      // Find node under screen coordinates (respecting camera, zoom, lens)
      function findNodeAtScreenPos(screenX, screenY) {
        const rect = canvas.getBoundingClientRect();
        const camXWrapped = wrap(camX, WORLD_WIDTH);
        const camYWrapped = wrap(camY, WORLD_HEIGHT);

        let closestNode = null;
        let closestDistance = Infinity;

        // Check all tiles
        const tileOffsets = [
          { x: -WORLD_WIDTH, y: -WORLD_HEIGHT },
          { x: -WORLD_WIDTH, y: 0 },
          { x: -WORLD_WIDTH, y: WORLD_HEIGHT },
          { x: 0, y: -WORLD_HEIGHT },
          { x: 0, y: 0 },
          { x: 0, y: WORLD_HEIGHT },
          { x: WORLD_WIDTH, y: -WORLD_HEIGHT },
          { x: WORLD_WIDTH, y: 0 },
          { x: WORLD_WIDTH, y: WORLD_HEIGHT }
        ];

        tileOffsets.forEach(offset => {
          nodes.forEach(node => {
            const nodeScreenX = (node.x + offset.x) * zoom + camXWrapped + rect.width / 2;
            const nodeScreenY = (node.y + offset.y) * zoom + camYWrapped + rect.height / 2;

            // Calculate lens scale for this node
            const dx = nodeScreenX - focusX;
            const dy = nodeScreenY - focusY;
            const distanceToFocus = Math.sqrt(dx * dx + dy * dy);
            const strength = Math.max(0, 1 - distanceToFocus / LENS_RADIUS);
            const lensScale = 1 + (LENS_MAX_SCALE - 1) * strength * strength;
            const scaledRadius = NODE_RADIUS * lensScale * zoom;

            const clickDx = screenX - nodeScreenX;
            const clickDy = screenY - nodeScreenY;
            const clickDistance = Math.sqrt(clickDx * clickDx + clickDy * clickDy);

            if (clickDistance < scaledRadius && clickDistance < closestDistance) {
              closestDistance = clickDistance;
              closestNode = node;
            }
          });
        });

        return closestNode;
      }

      // Camera animation loop
      function animate() {
        // Smooth camera easing
        camX += (targetCamX - camX) * CAM_EASING;
        camY += (targetCamY - camY) * CAM_EASING;

        // Smooth zoom easing
        zoom += (targetZoom - zoom) * ZOOM_EASING;

        // Smooth focus easing (for lens effect)
        focusX += (targetFocusX - focusX) * FOCUS_EASING;
        focusY += (targetFocusY - focusY) * FOCUS_EASING;

        // Camera remains continuous (wrapping only in render)

        render();
        requestAnimationFrame(animate);
      }

      // Pointer event handlers
      canvas.addEventListener('pointerdown', (e) => {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (activePointers.size === 2) {
          // Two fingers: start pinch zoom
          isDragging = false;
          hasDragged = false;
          canvas.classList.remove('dragging');

          const pointers = Array.from(activePointers.values());
          const dx = pointers[1].x - pointers[0].x;
          const dy = pointers[1].y - pointers[0].y;
          lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
          lastPinchMidX = (pointers[0].x + pointers[1].x) / 2;
          lastPinchMidY = (pointers[0].y + pointers[1].y) / 2;
        } else if (activePointers.size === 1) {
          // One finger: start drag pan
          isDragging = true;
          hasDragged = false;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          dragStartCamX = targetCamX;
          dragStartCamY = targetCamY;

          canvas.setPointerCapture(e.pointerId);
          canvas.classList.add('dragging');
        }
      });

      canvas.addEventListener('pointermove', (e) => {
        if (!activePointers.has(e.pointerId)) return;

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (activePointers.size === 2) {
          // Two fingers: pinch zoom
          const pointers = Array.from(activePointers.values());
          const dx = pointers[1].x - pointers[0].x;
          const dy = pointers[1].y - pointers[0].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const midX = (pointers[0].x + pointers[1].x) / 2;
          const midY = (pointers[0].y + pointers[1].y) / 2;

          if (lastPinchDistance > 0) {
            const scale = distance / lastPinchDistance;
            const newZoom = targetZoom * scale;
            applyAnchoredZoom(newZoom, midX, midY);
          }

          lastPinchDistance = distance;
          lastPinchMidX = midX;
          lastPinchMidY = midY;
        } else if (activePointers.size === 1 && isDragging) {
          // One finger: drag pan
          const deltaX = e.clientX - dragStartX;
          const deltaY = e.clientY - dragStartY;

          // Mark as dragged if moved more than 5 pixels
          if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
            hasDragged = true;
          }

          targetCamX = dragStartCamX + deltaX;
          targetCamY = dragStartCamY + deltaY;
        }
      });

      canvas.addEventListener('pointerup', (e) => {
        // Detect click (not drag)
        if (isDragging && !hasDragged && activePointers.size === 1) {
          const rect = canvas.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const clickY = e.clientY - rect.top;

          const clickedNode = findNodeAtScreenPos(clickX, clickY);

          if (clickedNode && clickedNode.icon.href) {
            // Open link
            window.open(clickedNode.icon.href, '_blank');
          }
        }

        activePointers.delete(e.pointerId);

        if (activePointers.size < 2) {
          lastPinchDistance = 0;
        }

        if (activePointers.size === 0) {
          isDragging = false;
          hasDragged = false;
          canvas.classList.remove('dragging');
        }

        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch (err) {
          // Ignore if pointer capture wasn't set
        }
      });

      canvas.addEventListener('pointercancel', (e) => {
        activePointers.delete(e.pointerId);

        if (activePointers.size < 2) {
          lastPinchDistance = 0;
        }

        if (activePointers.size === 0) {
          isDragging = false;
          canvas.classList.remove('dragging');
        }

        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch (err) {
          // Ignore if pointer capture wasn't set
        }
      });

      // Wheel event handler for trackpad/wheel panning and zoom
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        if (e.ctrlKey || e.metaKey) {
          // Ctrl/Meta + wheel: zoom anchored at cursor
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX;
          const mouseY = e.clientY;

          // Zoom in/out based on deltaY
          const zoomFactor = 1 - e.deltaY * 0.01;
          const newZoom = targetZoom * zoomFactor;

          applyAnchoredZoom(newZoom, mouseX, mouseY);
        } else {
          // Normal wheel: pan
          targetCamX -= e.deltaX;
          targetCamY -= e.deltaY;
        }
      }, { passive: false });

      // Mouse move handler for lens focus (desktop)
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        targetFocusX = e.clientX - rect.left;
        targetFocusY = e.clientY - rect.top;
      });

      // Initialize
      function init() {
        const rect = canvas.getBoundingClientRect();

        // Set initial focus to screen center (for mobile and desktop default)
        targetFocusX = rect.width / 2;
        targetFocusY = rect.height / 2;
        focusX = targetFocusX;
        focusY = targetFocusY;

        // Preload all icon images
        preloadImages();

        generateCircularGrid(rect.width, rect.height);
        animate();
      }

      // Handle window resize
      window.addEventListener('resize', () => {
        const rect = canvas.getBoundingClientRect();
        generateCircularGrid(rect.width, rect.height);
      });

      // Start
      init();
    </script>
  </body>
</html>
