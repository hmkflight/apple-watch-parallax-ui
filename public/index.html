<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple Watch Parallax UI</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; }
    #graph { position: fixed; inset: 0; width: 100vw; height: 100vh; }
    #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #0f0; padding: 8px; font-family: monospace; font-size: 11px; z-index: 1000; pointer-events: none; }
  </style>

  <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
  <!--<script src="../../dist/force-graph.js"></script>-->
</head>

<body>
  <div id="graph"></div>
  <div id="debug"></div>

  <script>
    // Generate hex coordinates in concentric rings with q,r coordinates
    function generateHexRings(N, spacing) {
      const positions = [];
      const sqrt3 = Math.sqrt(3);

      // Axial hex directions (6 sides of hexagon)
      const dirs = [
        [+1,  0], [+1, -1], [ 0, -1],
        [-1,  0], [-1, +1], [ 0, +1]
      ];

      // Center hex
      positions.push({ q: 0, r: 0 });

      // Generate rings outward from center
      let radius = 1;
      while (positions.length < N) {
        // Start at top-left of ring
        let q = -radius;
        let r = 0;

        // Walk around the ring
        for (let side = 0; side < 6; side++) {
          for (let step = 0; step < radius; step++) {
            if (positions.length >= N) break;
            positions.push({ q, r });
            // Move in current direction
            q += dirs[side][0];
            r += dirs[side][1];
          }
          if (positions.length >= N) break;
        }
        radius++;
      }

      // Convert axial (q,r) to pixel (x,y) - pointy-top hex
      return positions.map(({ q, r }) => ({
        q,
        r,
        x: spacing * sqrt3 * (q + r / 2),
        y: spacing * 1.5 * r
      }));
    }

    // Build links from immediate hex neighbors only
    function buildHexNeighborLinks(nodes) {
      const links = [];

      // Hex neighbor directions in axial coordinates
      const neighborDirs = [
        [+1,  0], [+1, -1], [ 0, -1],
        [-1,  0], [-1, +1], [ 0, +1]
      ];

      // Create lookup map: "q,r" -> node.id
      const coordMap = new Map();
      nodes.forEach(node => {
        coordMap.set(`${node.q},${node.r}`, node.id);
      });

      // For each node, check all 6 neighbor positions
      nodes.forEach(node => {
        neighborDirs.forEach(([dq, dr]) => {
          const neighborKey = `${node.q + dq},${node.r + dr}`;
          const neighborId = coordMap.get(neighborKey);

          // Only add link if neighbor exists and avoid duplicates
          if (neighborId !== undefined && node.id < neighborId) {
            links.push({
              source: node.id,
              target: neighborId
            });
          }
        });
      });

      return links;
    }

    // Configuration - spacing derived from node size for uniform appearance
    const N = 300;
    const nodeRadius = 12; // Tuned for Apple Watch aesthetic
    const gap = 12; // Gap between nodes
    const hexSpacing = (nodeRadius * 2) + gap; // Consistent spacing = 36

    const positions = generateHexRings(N, hexSpacing);

    // Create nodes with deterministic honeycomb positions and hex coordinates
    const nodes = [...Array(N).keys()].map(i => {
      const pos = positions[i];
      // Ensure finite anchor positions
      const anchorX = Number.isFinite(pos.x) ? pos.x : 0;
      const anchorY = Number.isFinite(pos.y) ? pos.y : 0;
      return {
        id: i,
        q: pos.q, // Axial hex coordinate
        r: pos.r, // Axial hex coordinate
        x: anchorX,
        y: anchorY,
        anchorX: anchorX, // Home position for anchor force
        anchorY: anchorY,
        radius: nodeRadius
      };
    });

    // Build links from immediate hex neighbors only (no spaghetti)
    const links = buildHexNeighborLinks(nodes);

    const gData = { nodes, links };

    // Custom anchor force to maintain honeycomb spacing (alpha-scaled)
    function anchorForce(strength = 0.02) {
      let nodes;

      function force(alpha) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];

          // Defensive guards against NaN/undefined
          if (!Number.isFinite(node.anchorX)) node.anchorX = 0;
          if (!Number.isFinite(node.anchorY)) node.anchorY = 0;
          if (!Number.isFinite(node.x)) node.x = node.anchorX;
          if (!Number.isFinite(node.y)) node.y = node.anchorY;
          if (!Number.isFinite(node.vx)) node.vx = 0;
          if (!Number.isFinite(node.vy)) node.vy = 0;

          // Apply alpha-scaled anchor force
          node.vx += (node.anchorX - node.x) * strength * alpha;
          node.vy += (node.anchorY - node.y) * strength * alpha;
        }
      }

      force.initialize = function(_) { nodes = _; };

      return force;
    }

    // Bulletproof sizing using container measurements
    const el = document.getElementById('graph');

    function updateGraphSize() {
      const rect = el.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      Graph.width(w).height(h);
    }

    const Graph = new ForceGraph()
      (el)
        .graphData(gData)
        .nodeVal(node => node.radius * 2) // Size based on radius
        .nodeRelSize(1.5) // Additional size multiplier
        .d3VelocityDecay(0.5) // Balanced friction for stability
        .d3AlphaDecay(0.08) // Moderate cooling rate
        .d3Force('charge', d3.forceManyBody().strength(-20)) // Mild repulsion
        .d3Force('center', null) // Remove centering force (already centered)
        .d3Force('collide', d3.forceCollide(node => node.radius + gap / 2).iterations(3)) // Uniform spacing
        .d3Force('anchor', anchorForce(0.02)) // Maintain honeycomb shape
        .onEngineStop(() => {
          // Prevent permanent stop - reheat and refresh
          const gd = Graph.graphData();
          if (gd?.nodes?.length) {
            Graph.d3ReheatSimulation();
            Graph.refresh();
          }
        });

    // Configure link force after graphData to match hex spacing
    const linkForce = Graph.d3Force('link');
    if (linkForce) {
      linkForce.distance(hexSpacing).strength(0.15); // Match spacing, moderate strength
    }

    // Apply initial size
    updateGraphSize();

    // ResizeObserver for container size changes
    const resizeObserver = new ResizeObserver(() => {
      updateGraphSize();
    });
    resizeObserver.observe(el);

    // Debug overlay (updates every second)
    const debugEl = document.getElementById('debug');
    setInterval(() => {
      const rect = el.getBoundingClientRect();
      const nodes = Graph.graphData().nodes;
      const anyFinite = nodes.some(n => Number.isFinite(n.x) && Number.isFinite(n.y));

      debugEl.innerHTML = `
        Container: ${Math.floor(rect.width)}Ã—${Math.floor(rect.height)}px<br>
        Zoom: ${Graph.zoom().toFixed(2)}<br>
        Nodes: ${nodes.length}<br>
        Links: ${Graph.graphData().links.length}<br>
        Finite positions: ${anyFinite ? 'YES' : 'NO'}
      `;
    }, 1000);

    // Safety net: periodic check and refresh (every 2 seconds)
    setInterval(() => {
      const gd = Graph.graphData();
      if (!gd?.nodes?.length) return;

      // Check if positions are valid
      const anyFinite = gd.nodes.some(n => Number.isFinite(n.x) && Number.isFinite(n.y));
      if (!anyFinite) {
        // Reset to anchors if positions became invalid
        gd.nodes.forEach(n => {
          n.x = n.anchorX || 0;
          n.y = n.anchorY || 0;
          n.vx = 0;
          n.vy = 0;
        });
        Graph.d3ReheatSimulation();
      }

      // Always refresh to prevent disappearance
      Graph.refresh();
    }, 2000);

    // Calm the simulation on load
    setTimeout(() => {
      Graph.d3AlphaDecay(0.05); // Slow down settling
    }, 500);
  </script>
</body>
</html>
