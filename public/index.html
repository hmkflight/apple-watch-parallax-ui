<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Apple Watch Parallax</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: grab;
        touch-action: none;
      }
      canvas.dragging {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Configuration
      const NODE_RADIUS = 28;
      const RING_SPACING = 70;
      const LINE_COLOR = 'rgba(80, 80, 80, 0.3)';
      const NODE_COLOR = '#1a1a1a';
      const NODE_STROKE = '#333';
      const TEXT_COLOR = '#fff';

      // Placeholder letters for icons
      const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

      let nodes = [];
      let links = [];

      // Camera state
      let camX = 0;
      let camY = 0;
      let targetCamX = 0;
      let targetCamY = 0;
      const CAM_EASING = 0.15;

      // Interaction state
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartCamX = 0;
      let dragStartCamY = 0;

      // Setup canvas with DPI scaling
      function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        ctx.scale(dpr, dpr);

        return { width: rect.width, height: rect.height };
      }

      // Generate concentric circular layout
      function generateCircularGrid(viewportWidth, viewportHeight) {
        // Calculate how many rings needed to fill viewport
        const maxRadius = Math.sqrt(viewportWidth * viewportWidth + viewportHeight * viewportHeight) / 2;
        const RING_COUNT = Math.ceil(maxRadius / RING_SPACING);

        nodes = [];
        let nodeId = 0;

        // Center node
        nodes.push({
          id: nodeId++,
          x: 0,
          y: 0,
          ring: 0,
          index: 0,
          letter: LETTERS[0 % LETTERS.length]
        });

        // Generate concentric rings
        for (let ring = 1; ring <= RING_COUNT; ring++) {
          const radius = ring * RING_SPACING;
          const circumference = 2 * Math.PI * radius;

          // Calculate how many nodes fit around this ring with proper spacing
          const nodesInRing = Math.max(6, Math.floor(circumference / (NODE_RADIUS * 2.5)));

          for (let i = 0; i < nodesInRing; i++) {
            const angle = (i / nodesInRing) * 2 * Math.PI;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            nodes.push({
              id: nodeId++,
              x,
              y,
              ring,
              index: i,
              nodesInRing,
              letter: LETTERS[nodeId % LETTERS.length]
            });
          }
        }

        // Generate neighbor links
        links = [];

        nodes.forEach(node => {
          if (node.ring === 0) return; // Skip center node for now

          // Connect to adjacent nodes in same ring
          const ringStart = nodes.findIndex(n => n.ring === node.ring);
          const ringSize = node.nodesInRing;

          // Next node in same ring
          const nextIndex = (node.index + 1) % ringSize;
          const nextId = ringStart + nextIndex;
          if (node.id < nextId) {
            links.push({ source: node.id, target: nextId });
          }

          // Connect to nodes in inner ring
          if (node.ring > 1) {
            const innerRingStart = nodes.findIndex(n => n.ring === node.ring - 1);
            const innerRing = nodes.filter(n => n.ring === node.ring - 1);

            // Find closest node(s) in inner ring by angle
            const nodeAngle = Math.atan2(node.y, node.x);
            innerRing.forEach(innerNode => {
              const innerAngle = Math.atan2(innerNode.y, innerNode.x);
              const angleDiff = Math.abs(nodeAngle - innerAngle);

              // Connect if angles are close (within reasonable arc)
              if (angleDiff < Math.PI / Math.max(6, innerNode.nodesInRing * 0.8)) {
                if (node.id > innerNode.id) {
                  links.push({ source: innerNode.id, target: node.id });
                }
              }
            });
          } else if (node.ring === 1) {
            // First ring connects to center
            links.push({ source: 0, target: node.id });
          }
        });
      }

      // Render the circular grid
      function render() {
        const { width, height } = setupCanvas();

        ctx.clearRect(0, 0, width, height);

        // Apply camera transform
        ctx.save();
        ctx.translate(width / 2 + camX, height / 2 + camY);

        // Draw links first (behind nodes)
        ctx.strokeStyle = LINE_COLOR;
        ctx.lineWidth = 1.5;

        links.forEach(link => {
          const source = nodes[link.source];
          const target = nodes[link.target];

          ctx.beginPath();
          ctx.moveTo(source.x, source.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
        });

        // Draw nodes
        nodes.forEach(node => {
          // Circle background
          ctx.fillStyle = NODE_COLOR;
          ctx.strokeStyle = NODE_STROKE;
          ctx.lineWidth = 2;

          ctx.beginPath();
          ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Subtle inner shadow effect
          const gradient = ctx.createRadialGradient(
            node.x, node.y - NODE_RADIUS * 0.3, 0,
            node.x, node.y, NODE_RADIUS
          );
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
          ctx.fillStyle = gradient;
          ctx.fill();

          // Placeholder letter/logo
          ctx.fillStyle = TEXT_COLOR;
          ctx.font = 'bold 18px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.letter, node.x, node.y);
        });

        ctx.restore();
      }

      // Camera animation loop
      function animate() {
        // Smooth camera easing
        camX += (targetCamX - camX) * CAM_EASING;
        camY += (targetCamY - camY) * CAM_EASING;

        render();
        requestAnimationFrame(animate);
      }

      // Pointer event handlers
      canvas.addEventListener('pointerdown', (e) => {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartCamX = targetCamX;
        dragStartCamY = targetCamY;

        canvas.setPointerCapture(e.pointerId);
        canvas.classList.add('dragging');
      });

      canvas.addEventListener('pointermove', (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;

        targetCamX = dragStartCamX + deltaX;
        targetCamY = dragStartCamY + deltaY;
      });

      canvas.addEventListener('pointerup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        canvas.releasePointerCapture(e.pointerId);
        canvas.classList.remove('dragging');
      });

      canvas.addEventListener('pointercancel', (e) => {
        if (!isDragging) return;
        isDragging = false;
        canvas.releasePointerCapture(e.pointerId);
        canvas.classList.remove('dragging');
      });

      // Wheel event handler for trackpad/wheel panning
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        targetCamX -= e.deltaX;
        targetCamY -= e.deltaY;
      }, { passive: false });

      // Initialize
      function init() {
        const rect = canvas.getBoundingClientRect();
        generateCircularGrid(rect.width, rect.height);
        animate();
      }

      // Handle window resize
      window.addEventListener('resize', () => {
        const rect = canvas.getBoundingClientRect();
        generateCircularGrid(rect.width, rect.height);
      });

      // Start
      init();
    </script>
  </body>
</html>
