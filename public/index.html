<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple Watch Parallax UI</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
    #canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; }
    #debug {
      position: fixed; top: 10px; left: 10px;
      background: rgba(0,0,0,0.8); color: #0f0;
      padding: 8px; font-family: monospace; font-size: 10px;
      pointer-events: none; z-index: 1000;
    }
  </style>
  <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="debug"></div>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    const N = 220;              // Number of nodes
    const radius = 6;           // Circle radius
    const gap = 10;             // Gap between circles
    const spacing = radius * 2 + gap; // 22px hex spacing

    // ========================================
    // HEX RING GENERATION (DETERMINISTIC)
    // ========================================
    function hexRingCoords(N) {
      const coords = [];
      const dirs = [
        [1, 0], [1, -1], [0, -1],
        [-1, 0], [-1, 1], [0, 1]
      ];

      // Center
      coords.push({ q: 0, r: 0 });

      // Concentric rings
      let ring = 1;
      while (coords.length < N) {
        let q = -ring;
        let r = 0;

        for (let side = 0; side < 6; side++) {
          for (let step = 0; step < ring; step++) {
            if (coords.length >= N) break;
            coords.push({ q, r });
            q += dirs[side][0];
            r += dirs[side][1];
          }
          if (coords.length >= N) break;
        }
        ring++;
      }

      return coords;
    }

    // Convert axial (q,r) to pixel (x,y) - pointy-top hex
    function axialToPixel(q, r, spacing) {
      const sqrt3 = Math.sqrt(3);
      return {
        x: spacing * sqrt3 * (q + r / 2),
        y: spacing * (3 / 2) * r
      };
    }

    // ========================================
    // CREATE NODES
    // ========================================
    const hexCoords = hexRingCoords(N);
    const nodes = hexCoords.map((coord, i) => {
      const { x, y } = axialToPixel(coord.q, coord.r, spacing);
      return {
        id: i,
        q: coord.q,
        r: coord.r,
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        anchorX: x,
        anchorY: y,
        radius: radius
      };
    });

    // ========================================
    // BUILD NEIGHBOR LINKS (SHORT EDGES ONLY)
    // ========================================
    const coordMap = new Map();
    nodes.forEach(node => {
      coordMap.set(`${node.q},${node.r}`, node.id);
    });

    const neighborDirs = [
      [1, 0], [1, -1], [0, -1],
      [-1, 0], [-1, 1], [0, 1]
    ];

    const links = [];
    nodes.forEach(node => {
      neighborDirs.forEach(([dq, dr]) => {
        const neighborId = coordMap.get(`${node.q + dq},${node.r + dr}`);
        if (neighborId !== undefined && node.id < neighborId) {
          links.push({ source: node.id, target: neighborId });
        }
      });
    });

    // ========================================
    // COMPUTE WORLD BOUNDS
    // ========================================
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    nodes.forEach(n => {
      if (n.anchorX < minX) minX = n.anchorX;
      if (n.anchorX > maxX) maxX = n.anchorX;
      if (n.anchorY < minY) minY = n.anchorY;
      if (n.anchorY > maxY) maxY = n.anchorY;
    });

    const WORLD_W = (maxX - minX) + spacing * 2;
    const WORLD_H = (maxY - minY) + spacing * 2;

    // ========================================
    // D3-FORCE SIMULATION (STRONG ANCHORS)
    // ========================================
    const simulation = d3.forceSimulation(nodes)
      .force("collide", d3.forceCollide(n => n.radius + gap / 2).iterations(2))
      .force("x", d3.forceX(n => n.anchorX).strength(0.35))
      .force("y", d3.forceY(n => n.anchorY).strength(0.35))
      .force("charge", d3.forceManyBody().strength(-2))
      .velocityDecay(0.6)
      .alpha(1)
      .alphaDecay(0.12);

    // ========================================
    // CANVAS SETUP (DPI SAFE)
    // ========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ========================================
    // CAMERA (INFINITE WRAPAROUND)
    // ========================================
    let camX = 0;
    let camY = 0;
    let targetCamX = 0;
    let targetCamY = 0;

    // Scroll handler (infinite wrap)
    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      const scrollSpeed = 0.8;
      targetCamX += e.deltaX * scrollSpeed;
      targetCamY += e.deltaY * scrollSpeed;
    }, { passive: false });

    // Mouse drag (optional)
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let camStartX = 0, camStartY = 0;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      camStartX = targetCamX;
      camStartY = targetCamY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        targetCamX = camStartX - (e.clientX - dragStartX);
        targetCamY = camStartY - (e.clientY - dragStartY);
      }
    });

    canvas.addEventListener('mouseup', () => { isDragging = false; });
    canvas.addEventListener('mouseleave', () => { isDragging = false; });

    // ========================================
    // TILED RENDERING (9 TILES FOR SEAMLESS WRAP)
    // ========================================
    function render() {
      // Smooth camera easing
      camX += (targetCamX - camX) * 0.08;
      camY += (targetCamY - camY) * 0.08;

      // Wrap camera position (toroidal)
      camX = ((camX % WORLD_W) + WORLD_W) % WORLD_W;
      camY = ((camY % WORLD_H) + WORLD_H) % WORLD_H;

      // Also wrap targets to prevent drift
      targetCamX = ((targetCamX % WORLD_W) + WORLD_W) % WORLD_W;
      targetCamY = ((targetCamY % WORLD_H) + WORLD_H) % WORLD_H;

      // Clear canvas
      const w = canvas.width / dpr;
      const h = canvas.height / dpr;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);

      const centerX = w / 2;
      const centerY = h / 2;

      // Draw 9 tiles (3x3 grid) for seamless wraparound
      const offsets = [
        [-WORLD_W, -WORLD_H], [0, -WORLD_H], [WORLD_W, -WORLD_H],
        [-WORLD_W, 0],        [0, 0],        [WORLD_W, 0],
        [-WORLD_W, WORLD_H],  [0, WORLD_H],  [WORLD_W, WORLD_H]
      ];

      offsets.forEach(([ox, oy]) => {
        // Draw links first
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        links.forEach(link => {
          const source = nodes[link.source];
          const target = nodes[link.target];
          const sx = (source.x - camX) + ox + centerX;
          const sy = (source.y - camY) + oy + centerY;
          const tx = (target.x - camX) + ox + centerX;
          const ty = (target.y - camY) + oy + centerY;
          ctx.moveTo(sx, sy);
          ctx.lineTo(tx, ty);
        });
        ctx.stroke();

        // Draw nodes
        nodes.forEach(node => {
          const screenX = (node.x - camX) + ox + centerX;
          const screenY = (node.y - camY) + oy + centerY;

          ctx.beginPath();
          ctx.arc(screenX, screenY, node.radius, 0, 2 * Math.PI);
          ctx.fillStyle = '#fff';
          ctx.fill();
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.lineWidth = 1;
          ctx.stroke();
        });
      });
    }

    // ========================================
    // ANIMATION LOOP
    // ========================================
    function animate() {
      simulation.tick();
      render();
      requestAnimationFrame(animate);
    }

    // ========================================
    // DEBUG OVERLAY
    // ========================================
    const debugEl = document.getElementById('debug');
    setInterval(() => {
      debugEl.innerHTML = `
        Nodes: ${nodes.length}<br>
        Links: ${links.length}<br>
        World: ${Math.round(WORLD_W)}Ã—${Math.round(WORLD_H)}<br>
        Cam: ${Math.round(camX)}, ${Math.round(camY)}<br>
        Alpha: ${simulation.alpha().toFixed(3)}
      `;
    }, 100);

    // ========================================
    // START
    // ========================================
    animate();
  </script>
</body>
</html>
