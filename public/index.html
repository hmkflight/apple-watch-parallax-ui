<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple Watch Parallax UI</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { background: #000; }
    #canvas { display: block; width: 100%; height: 100%; cursor: grab; }
    #canvas:active { cursor: grabbing; }
    #debug {
      position: fixed; top: 10px; left: 10px;
      background: rgba(0,0,0,0.7); color: #0f0;
      padding: 8px; font-family: monospace; font-size: 11px;
      z-index: 1000; pointer-events: none;
    }
  </style>

  <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="debug"></div>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    const N = 300;              // Number of nodes
    const nodeRadius = 12;      // Circle radius
    const gap = 10;             // Gap between nodes
    const hexSpacing = (nodeRadius * 2) + gap; // 34px between centers

    // ========================================
    // HONEYCOMB GENERATION (DETERMINISTIC)
    // ========================================
    // Generates nodes in concentric hex rings around (0,0)
    // Returns array of {q, r, x, y} positions in axial coordinates
    function generateHexRings(N, spacing) {
      const positions = [];
      const sqrt3 = Math.sqrt(3);

      // Axial hex directions (6 sides)
      const dirs = [
        [+1,  0], [+1, -1], [ 0, -1],
        [-1,  0], [-1, +1], [ 0, +1]
      ];

      // Center
      positions.push({ q: 0, r: 0 });

      // Generate concentric rings
      let radius = 1;
      while (positions.length < N) {
        let q = -radius;
        let r = 0;

        for (let side = 0; side < 6; side++) {
          for (let step = 0; step < radius; step++) {
            if (positions.length >= N) break;
            positions.push({ q, r });
            q += dirs[side][0];
            r += dirs[side][1];
          }
          if (positions.length >= N) break;
        }
        radius++;
      }

      // Convert axial (q,r) to pixel (x,y) - pointy-top hex
      return positions.map(({ q, r }) => ({
        q,
        r,
        x: spacing * sqrt3 * (q + r / 2),
        y: spacing * 1.5 * r
      }));
    }

    // ========================================
    // BUILD HEX NEIGHBOR LINKS (OPTIONAL)
    // ========================================
    // Creates links only between immediate hex neighbors (max 6 per node)
    function buildHexNeighborLinks(nodes) {
      const links = [];
      const neighborDirs = [
        [+1,  0], [+1, -1], [ 0, -1],
        [-1,  0], [-1, +1], [ 0, +1]
      ];

      // Map: "q,r" -> node
      const coordMap = new Map();
      nodes.forEach(node => {
        coordMap.set(`${node.q},${node.r}`, node);
      });

      // For each node, check 6 neighbors
      nodes.forEach(node => {
        neighborDirs.forEach(([dq, dr]) => {
          const neighborKey = `${node.q + dq},${node.r + dr}`;
          const neighbor = coordMap.get(neighborKey);

          // Add link if neighbor exists (avoid duplicates)
          if (neighbor && node.id < neighbor.id) {
            links.push({ source: node, target: neighbor });
          }
        });
      });

      return links;
    }

    // ========================================
    // CREATE NODES & LINKS
    // ========================================
    const positions = generateHexRings(N, hexSpacing);
    const nodes = positions.map((pos, i) => ({
      id: i,
      q: pos.q,
      r: pos.r,
      x: pos.x,
      y: pos.y,
      anchorX: pos.x,  // Home position
      anchorY: pos.y,
      vx: 0,
      vy: 0,
      radius: nodeRadius
    }));

    const links = buildHexNeighborLinks(nodes);

    // ========================================
    // D3-FORCE SIMULATION
    // ========================================
    // Keeps honeycomb stable with subtle motion
    const simulation = d3.forceSimulation(nodes)
      .force('collide', d3.forceCollide(d => d.radius + gap / 2).iterations(3))
      .force('charge', d3.forceManyBody().strength(-15))
      .force('link', d3.forceLink(links).distance(hexSpacing).strength(0.1))
      .force('anchor', () => {
        // Custom anchor force: pulls nodes gently back to home positions
        const strength = 0.02;
        const alpha = simulation.alpha();
        nodes.forEach(node => {
          if (!Number.isFinite(node.x)) node.x = node.anchorX;
          if (!Number.isFinite(node.y)) node.y = node.anchorY;
          if (!Number.isFinite(node.vx)) node.vx = 0;
          if (!Number.isFinite(node.vy)) node.vy = 0;

          node.vx += (node.anchorX - node.x) * strength * alpha;
          node.vy += (node.anchorY - node.y) * strength * alpha;
        });
      })
      .alphaDecay(0.05)
      .velocityDecay(0.5);

    // ========================================
    // CANVAS SETUP
    // ========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    // Handle window resize
    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });

    // ========================================
    // CAMERA SYSTEM (PAN/ZOOM)
    // ========================================
    let camera = {
      x: 0,         // Camera offset X
      y: 0,         // Camera offset Y
      zoom: 1,      // Zoom level
      targetZoom: 1 // Smooth zoom target
    };

    // Mouse interaction state
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let cameraStart = { x: 0, y: 0 };

    // Mouse down: start drag
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      cameraStart = { x: camera.x, y: camera.y };
    });

    // Mouse move: pan camera
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        camera.x = cameraStart.x + dx;
        camera.y = cameraStart.y + dy;
      }
    });

    // Mouse up: stop drag
    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Mouse wheel: zoom
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomSpeed = 0.001;
      camera.targetZoom *= (1 - e.deltaY * zoomSpeed);
      camera.targetZoom = Math.max(0.5, Math.min(3, camera.targetZoom));
    }, { passive: false });

    // ========================================
    // RENDERING LOOP
    // ========================================
    function render() {
      // Smooth zoom
      camera.zoom += (camera.targetZoom - camera.zoom) * 0.1;

      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      // Apply camera transform
      ctx.save();
      ctx.translate(width / 2 + camera.x, height / 2 + camera.y);
      ctx.scale(camera.zoom, camera.zoom);

      // Draw links (thin gray lines)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.lineWidth = 1 / camera.zoom;
      ctx.beginPath();
      links.forEach(link => {
        ctx.moveTo(link.source.x, link.source.y);
        ctx.lineTo(link.target.x, link.target.y);
      });
      ctx.stroke();

      // Draw nodes (white circles)
      nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 2 / camera.zoom;
        ctx.stroke();
      });

      ctx.restore();

      requestAnimationFrame(render);
    }

    // ========================================
    // DEBUG OVERLAY
    // ========================================
    const debugEl = document.getElementById('debug');
    setInterval(() => {
      debugEl.innerHTML = `
        Canvas: ${width}Ã—${height}px<br>
        Zoom: ${camera.zoom.toFixed(2)}<br>
        Nodes: ${nodes.length}<br>
        Links: ${links.length}<br>
        Alpha: ${simulation.alpha().toFixed(3)}
      `;
    }, 1000);

    // ========================================
    // START
    // ========================================
    render();
  </script>
</body>
</html>
