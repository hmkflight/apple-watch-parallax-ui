<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Apple Watch Parallax</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: grab;
        touch-action: none;
      }
      canvas.dragging {
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Configuration
      const NODE_RADIUS = 28;
      const RING_SPACING = 70;
      const LINE_COLOR = 'rgba(80, 80, 80, 0.3)';
      const NODE_COLOR = '#1a1a1a';
      const NODE_STROKE = '#333';
      const TEXT_COLOR = '#fff';

      // Placeholder letters for icons
      const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

      let nodes = [];
      let links = [];

      // Camera state
      let camX = 0;
      let camY = 0;
      let targetCamX = 0;
      let targetCamY = 0;
      const CAM_EASING = 0.15;

      // Zoom state
      let zoom = 1;
      let targetZoom = 1;
      const MIN_ZOOM = 0.6;
      const MAX_ZOOM = 2.5;
      const ZOOM_EASING = 0.2;

      // Interaction state
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartCamX = 0;
      let dragStartCamY = 0;

      // Pinch state
      const activePointers = new Map();
      let lastPinchDistance = 0;
      let lastPinchMidX = 0;
      let lastPinchMidY = 0;

      // Setup canvas with DPI scaling
      function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        ctx.scale(dpr, dpr);

        return { width: rect.width, height: rect.height };
      }

      // Anchored zoom: adjust camera so world point under screen point stays fixed
      function applyAnchoredZoom(newZoom, screenX, screenY) {
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;

        // World point before zoom
        const worldXBefore = (screenX - centerX - targetCamX) / zoom;
        const worldYBefore = (screenY - centerY - targetCamY) / zoom;

        // Clamp zoom
        targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

        // World point after zoom (should stay at same screen position)
        // screenX = centerX + targetCamX + worldX * targetZoom
        // Solve for new targetCamX/Y
        targetCamX = screenX - centerX - worldXBefore * targetZoom;
        targetCamY = screenY - centerY - worldYBefore * targetZoom;
      }

      // Generate concentric circular layout
      function generateCircularGrid(viewportWidth, viewportHeight) {
        // Calculate how many rings needed to fill viewport
        const maxRadius = Math.sqrt(viewportWidth * viewportWidth + viewportHeight * viewportHeight) / 2;
        const RING_COUNT = Math.ceil(maxRadius / RING_SPACING);

        nodes = [];
        let nodeId = 0;

        // Center node
        nodes.push({
          id: nodeId++,
          x: 0,
          y: 0,
          ring: 0,
          index: 0,
          letter: LETTERS[0 % LETTERS.length]
        });

        // Generate concentric rings
        for (let ring = 1; ring <= RING_COUNT; ring++) {
          const radius = ring * RING_SPACING;
          const circumference = 2 * Math.PI * radius;

          // Calculate how many nodes fit around this ring with proper spacing
          const nodesInRing = Math.max(6, Math.floor(circumference / (NODE_RADIUS * 2.5)));

          for (let i = 0; i < nodesInRing; i++) {
            const angle = (i / nodesInRing) * 2 * Math.PI;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            nodes.push({
              id: nodeId++,
              x,
              y,
              ring,
              index: i,
              nodesInRing,
              letter: LETTERS[nodeId % LETTERS.length]
            });
          }
        }

        // Generate neighbor links
        links = [];

        nodes.forEach(node => {
          if (node.ring === 0) return; // Skip center node for now

          // Connect to adjacent nodes in same ring
          const ringStart = nodes.findIndex(n => n.ring === node.ring);
          const ringSize = node.nodesInRing;

          // Next node in same ring
          const nextIndex = (node.index + 1) % ringSize;
          const nextId = ringStart + nextIndex;
          if (node.id < nextId) {
            links.push({ source: node.id, target: nextId });
          }

          // Connect to nodes in inner ring
          if (node.ring > 1) {
            const innerRingStart = nodes.findIndex(n => n.ring === node.ring - 1);
            const innerRing = nodes.filter(n => n.ring === node.ring - 1);

            // Find closest node(s) in inner ring by angle
            const nodeAngle = Math.atan2(node.y, node.x);
            innerRing.forEach(innerNode => {
              const innerAngle = Math.atan2(innerNode.y, innerNode.x);
              const angleDiff = Math.abs(nodeAngle - innerAngle);

              // Connect if angles are close (within reasonable arc)
              if (angleDiff < Math.PI / Math.max(6, innerNode.nodesInRing * 0.8)) {
                if (node.id > innerNode.id) {
                  links.push({ source: innerNode.id, target: node.id });
                }
              }
            });
          } else if (node.ring === 1) {
            // First ring connects to center
            links.push({ source: 0, target: node.id });
          }
        });
      }

      // Render the circular grid
      function render() {
        const { width, height } = setupCanvas();

        ctx.clearRect(0, 0, width, height);

        // Apply camera transform: translate to center, apply camera offset, then scale
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.translate(camX, camY);
        ctx.scale(zoom, zoom);

        // Draw links first (behind nodes)
        ctx.strokeStyle = LINE_COLOR;
        ctx.lineWidth = 1.5;

        links.forEach(link => {
          const source = nodes[link.source];
          const target = nodes[link.target];

          ctx.beginPath();
          ctx.moveTo(source.x, source.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
        });

        // Draw nodes
        nodes.forEach(node => {
          // Circle background
          ctx.fillStyle = NODE_COLOR;
          ctx.strokeStyle = NODE_STROKE;
          ctx.lineWidth = 2;

          ctx.beginPath();
          ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Subtle inner shadow effect
          const gradient = ctx.createRadialGradient(
            node.x, node.y - NODE_RADIUS * 0.3, 0,
            node.x, node.y, NODE_RADIUS
          );
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
          ctx.fillStyle = gradient;
          ctx.fill();

          // Placeholder letter/logo
          ctx.fillStyle = TEXT_COLOR;
          ctx.font = 'bold 18px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.letter, node.x, node.y);
        });

        ctx.restore();
      }

      // Camera animation loop
      function animate() {
        // Smooth camera easing
        camX += (targetCamX - camX) * CAM_EASING;
        camY += (targetCamY - camY) * CAM_EASING;

        // Smooth zoom easing
        zoom += (targetZoom - zoom) * ZOOM_EASING;

        render();
        requestAnimationFrame(animate);
      }

      // Pointer event handlers
      canvas.addEventListener('pointerdown', (e) => {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (activePointers.size === 2) {
          // Two fingers: start pinch zoom
          isDragging = false;
          canvas.classList.remove('dragging');

          const pointers = Array.from(activePointers.values());
          const dx = pointers[1].x - pointers[0].x;
          const dy = pointers[1].y - pointers[0].y;
          lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
          lastPinchMidX = (pointers[0].x + pointers[1].x) / 2;
          lastPinchMidY = (pointers[0].y + pointers[1].y) / 2;
        } else if (activePointers.size === 1) {
          // One finger: start drag pan
          isDragging = true;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          dragStartCamX = targetCamX;
          dragStartCamY = targetCamY;

          canvas.setPointerCapture(e.pointerId);
          canvas.classList.add('dragging');
        }
      });

      canvas.addEventListener('pointermove', (e) => {
        if (!activePointers.has(e.pointerId)) return;

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (activePointers.size === 2) {
          // Two fingers: pinch zoom
          const pointers = Array.from(activePointers.values());
          const dx = pointers[1].x - pointers[0].x;
          const dy = pointers[1].y - pointers[0].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const midX = (pointers[0].x + pointers[1].x) / 2;
          const midY = (pointers[0].y + pointers[1].y) / 2;

          if (lastPinchDistance > 0) {
            const scale = distance / lastPinchDistance;
            const newZoom = targetZoom * scale;
            applyAnchoredZoom(newZoom, midX, midY);
          }

          lastPinchDistance = distance;
          lastPinchMidX = midX;
          lastPinchMidY = midY;
        } else if (activePointers.size === 1 && isDragging) {
          // One finger: drag pan
          const deltaX = e.clientX - dragStartX;
          const deltaY = e.clientY - dragStartY;

          targetCamX = dragStartCamX + deltaX;
          targetCamY = dragStartCamY + deltaY;
        }
      });

      canvas.addEventListener('pointerup', (e) => {
        activePointers.delete(e.pointerId);

        if (activePointers.size < 2) {
          lastPinchDistance = 0;
        }

        if (activePointers.size === 0) {
          isDragging = false;
          canvas.classList.remove('dragging');
        }

        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch (err) {
          // Ignore if pointer capture wasn't set
        }
      });

      canvas.addEventListener('pointercancel', (e) => {
        activePointers.delete(e.pointerId);

        if (activePointers.size < 2) {
          lastPinchDistance = 0;
        }

        if (activePointers.size === 0) {
          isDragging = false;
          canvas.classList.remove('dragging');
        }

        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch (err) {
          // Ignore if pointer capture wasn't set
        }
      });

      // Wheel event handler for trackpad/wheel panning and zoom
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        if (e.ctrlKey || e.metaKey) {
          // Ctrl/Meta + wheel: zoom anchored at cursor
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX;
          const mouseY = e.clientY;

          // Zoom in/out based on deltaY
          const zoomFactor = 1 - e.deltaY * 0.01;
          const newZoom = targetZoom * zoomFactor;

          applyAnchoredZoom(newZoom, mouseX, mouseY);
        } else {
          // Normal wheel: pan
          targetCamX -= e.deltaX;
          targetCamY -= e.deltaY;
        }
      }, { passive: false });

      // Initialize
      function init() {
        const rect = canvas.getBoundingClientRect();
        generateCircularGrid(rect.width, rect.height);
        animate();
      }

      // Handle window resize
      window.addEventListener('resize', () => {
        const rect = canvas.getBoundingClientRect();
        generateCircularGrid(rect.width, rect.height);
      });

      // Start
      init();
    </script>
  </body>
</html>
